#Phys Prog23.py
'''
prog23.py

Date Made: 02/13/19
Purpose: Model a basic electric field created by a single point partical with a set charge.

Details: The program works by creating a single point charge and measuring the strength of the electric field
created a set distance away from the charge. The various points at which the strength is measured is generated by a circle.
The strength and direction of the electric field are shown by arrows with lengths proportional to the strength.

Features: There is a button that when pressed switches the sign of charge of the point particle thus reversing the arrows.

'''


from vpython import *
from math import *

'''
Setting parameters

1/(4 * pi * eplison), charge of electron, scaling factor for arrows, point particle, charge of point particle,
max theta value, change in theta, circle radius, empty lists for the arrows.

'''

oofpez = 9e9
qe = 1.6e-19
sf = 3e-16
source = sphere(pos = vec(0, 0, 0), radius = 1e-9, color = color.red)
q_source= qe
thetamax = 2 * pi
dtheta = pi/6
R = 1e-8
arrowListXY = []
arrowListYZ = []

# Function that is called when the button is pressed.
# It changes the sign of the source particle's charge and deletes all the current arrows
def modifyCharge(evt):
    global q_source
    q_source *= -1
    for index in range(len(arrowListXY)):
        arrowListXY[index].visible = False
        arrowListYZ[index].visible = False
    del arrowListXY[:]
    del arrowListYZ[:]

# Creates a button that when pressed calls the modify charge function
b1 = button(pos = scene.caption_anchor, bind = modifyCharge, text = 'Click to swtich source charge.')


'''
Main program

Starts with theta as zero. First checks to see if the arrow list is empty, which is when starting the
program and when the modifyCharge function is called. A circle is generated with a constant radius over a incremental
theta steps. At each point in the circle, a vector is computed from the origin to the point. The vector is normalized,
and is used to calculate the electric field at that point. The magnitude of the electric field is scaled down, and an
arrow is created with the scaled down electric field and the direction of the electric field. Once all the arrows are created,
the program waits until the button is pressed.
'''

theta = 0
while True:
    if len(arrowListXY) == 0:
        theta = 0
        while theta < thetamax:
            rate(500)
            # Calculates the radius vector in the circle
            r_obs1 = R * vector(cos(theta), cos(pi/2 - theta), 0)
            r_obs2 = R * vector(0, cos(theta), cos(pi/2 - theta))
            # Calculates vector from source to the point
            r1 = r_obs1 - source.pos
            r2 = r_obs2 - source.pos
            # normalizes the vector
            rhat1 = r1/mag(r1)
            rhat2 = r2/mag(r2)
            # calculates electric field
            E_1 = (oofpez * q_source / mag(r1) ** 2) * rhat1
            E_2 = (oofpez * q_source / mag(r2) ** 2) * rhat2
            # creates and adds arrows to the list 
            arrowListXY.append(arrow(pos = r_obs1 + -.5 * sf * E_1, color = color.orange, axis = sf * E_1, shaftwidth = source.radius))
            arrowListYZ.append(arrow(pos = r_obs2 + -.5 * sf * E_2, color = color.blue, axis = sf * E_2, shaftwidth = source.radius))
            theta = theta + dtheta
    continue
