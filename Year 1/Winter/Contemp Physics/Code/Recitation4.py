import sys
sys.path.append('/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/')

'''
Title: Phys 115 Reciation4
Name: Christopher Morris
Date: 06/07/19

The program is made to model a basic idea of the the radiative electric and magnetic fields generated by an accerlating particle.

The program works by making a shell of radiative electric and magnetic field arrows each with inital axis of zero.
As the program runs through dt, and when it encounters an r value that would have been reached by the traveling wave at that time,
the arrows are upated by their field values. This allows for multiple shells to be created and updated because when they are created,
the times at which their shell would need to be expanded outwards and updated is noted inside the object.

A button is made that accerlates the particle by adding to a counter that decreases every time step, though this does not pysically move
the particle much because of the significantly small dt, however, the individual wave pulses are seperated by short distances meaning
the particle did move and that the waves aren't propogating from the origin.

'''

import vpython as vp
import math

#constants
a = vp.vec(0,-2e17, 0)
q = 1e-16
c = 3e8
coulomb = 8.99e9


class Radiation(): #Radiation class that is called every time the button is pressed.
    def __init__(self, t, particle_pos, particle_acceleration):
        print('radiation made at:', particle_pos) #show that the arrows aren't originiating from the origin
        self.arrows = [] #stores arrows
        self.particle_position = particle_pos #where it's originiating

        #constants, dr: difference in radius for each shell, dtheta/dphi: used to generate spherical shell
        self.dr = .5e-12
        self.dtheta = math.pi/6
        self.dphi = math.pi/6
        self.r0 = .3e-11 #inital r

        self.a = particle_acceleration #particle accerlation
        self.q = 1e-16 #charge
        self.c = 3e8 #speed of light
        self.coulomb = 8.99e9 #coloumb charge (k and what not)
        self.i = 0 #index to keep track of how many shell movements outwards

        self.time_made = t #time called
        self.dt = self.dr / self.c #dt
        self.time_move = self.time_made + self.dt #when matches with dt will move shell outwards by dr

        self.setArrows1(self.r0) #makes arrows

    def setArrows1(self, r): #makes arrows using spherical coordinates
        theta = 0
        while theta < 2*math.pi:
            phi = 0
            while phi < 2*math.pi:
                self.arrows.append(RadiationArrow(r, theta, phi, self.particle_position))
                phi += self.dphi
            theta += self.dtheta


    def moveArrows(self): #moves arrows outwards by dr, and uses i to keep track, once i reaches ten the arrows are removed
        r = self.r0 + self.i * self.dr
        for arrow in self.arrows:
            arrow.updateArrow(r, self.i)
        self.i += 1

        if self.i == 30:
            self.removeSelf()

    def removeSelf(self): #removes arrows from list and makes their radii 0
        global radiation
        for arrow in self.arrows:
            arrow.scaling = 0
            arrow.updateArrow(self.r0, self.i)
        radiation.remove(self)

        del self

    def check_time(self, simulation_time): #called at each time step, if makes t then updates the arrows
        if self.time_move <= simulation_time:
            self.moveArrows()
            self.time_move += self.dt


class RadiationArrow(): #used to make arrows in radiation
    def __init__(self, r, theta, phi, particle_pos):
        #x, y, r, position (from particle position), scaling is found scaling factor that makes arrows visle, initial E and B arrows
        self.x = math.cos(theta) * math.sin(phi)
        self.y = math.sin(theta) * math.sin(phi)
        self.z = math.cos(phi)
        self.r = r
        self.position = vp.vec(self.x, self.y, self.z) + particle_pos
        self.scaling = 1e-34 # Found through a lot of experimentation
        self.Earrow = vp.arrow(pos = self.setPosition(r), axis = vp.vec(0,0,0)*self.scaling, color = vp.color.orange)
        self.Barrow = vp.arrow(pos = self.setPosition(r), axis = vp.vec(0,0,0)*self.scaling, color = vp.color.blue )

    def setPosition(self, r): #made position vector initially bassed off of cos/sin, and just mulitplies by scalar to increase shell radius
        return r * self.position

    def setAxis(self, r, i): #gets radius, and by using the equations of radiative E and B field, returns the new arrow axis
        radius = self.setPosition(r)
        a_perp = a - vp.proj(a, radius)
        temp = (coulomb * -q * a_perp / r)
        # temp = vp.norm(temp)
        return temp * self.scaling, -1 * vp.cross(temp, radius/r) * self.scaling

    def updateArrow(self, r, i): #moves arrows outwards and updates their axis
        new_position = self.setPosition(r)
        self.Earrow.pos, self.Barrow.pos = new_position, new_position
        self.Earrow.axis, self.Barrow.axis = self.setAxis(r, i)

def make_radiation(): #function called by button
    global t, dt, main_particle, acceleration_arrow
    radiation.append(Radiation(t, main_particle.pos, main_particle.acceleration))
    main_particle.accelerate_time += 1e4 #counter to countinue acceleration


main_particle = vp.sphere(pos = vp.vec(0,0,0), velocity = vp.vec(0,0,0), acceleration = vp.vec(0,-2e17, 0), radius = 1e-13, color = vp.color.red, accelerate_time = 0)
#main particle

vp.scene.background = vp.color.white
b1 = vp.button(pos=vp.scene.caption_anchor, text='Accelerate', bind = make_radiation)

radiation = [] #instances of Radiation class
vp.rate(5)
t = 0
dt = .00001e-20 #really small to see the radiation propogate outwards because it's so fast the the dr is super small

while True:

    for item in radiation:
        item.check_time(t) #calls the Radiation check time to see if it needs to move the single shell outwards

    if main_particle.accelerate_time != 0: #when counter isn't zero update the particle position
        main_particle.velocity += main_particle.acceleration * dt
        main_particle.pos += main_particle.velocity * dt
        main_particle.accelerate_time -= 1

    t += dt
